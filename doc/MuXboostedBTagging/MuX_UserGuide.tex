\documentclass[10pt]{article}

\usepackage{listings}
\usepackage{color}
\usepackage{cancel}
\usepackage{hyperref}

%\usepackage{graphicx}% Include figure files
%\usepackage{subfig}
%\usepackage{wasysym} %wavy symbols (e.g. \apprge)

\definecolor{dkgreen}{rgb}{0,0.4,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

% Set up the listings package for displaying tcl code
\lstset{frame=tb,
  language=c++,
  morekeywords={Int_t, Jet, TClonesArray, TIterator},
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=fixed,
  basicstyle={\scriptsize\ttfamily\bfseries},
  numbers=none,
  numberstyle=\color{mauve},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  literate=%
    {0}{{{\color{mauve}0}}}1
    {1}{{{\color{mauve}1}}}1
    {2}{{{\color{mauve}2}}}1
    {3}{{{\color{mauve}3}}}1
    {4}{{{\color{mauve}4}}}1
    {5}{{{\color{mauve}5}}}1
    {6}{{{\color{mauve}6}}}1
    {7}{{{\color{mauve}7}}}1
    {8}{{{\color{mauve}8}}}1
    {9}{{{\color{mauve}9}}}1
}

\newcommand{\muX}{$\mu_{x}^{}$}
\newcommand{\muXmodFull}{\texttt{MuXboostedBTagging}}
\newcommand{\muXmod}{\texttt{MuX}}
\newcommand{\delphes}{\textsc{Delphes}}

\newcommand{\pT}{p_{T}^{}}
\newcommand{\MET}{\cancel{E}_{T}^{}}

\newcommand{\pSubjet}[1][] {p_{\mathrm{subjet}}^{#1}}
\newcommand{\pCore}[1][]   {p_{\mathrm{core}}^{#1}}
\newcommand{\pCoreV}       {\vec{p}_{\mathrm{core}}^{}}
\newcommand{\pMu}[1][]     {p_{\mu}^{#1}}
\newcommand{\pMuV}       {\vec{p}_{\mu}^{}}
\newcommand{\pNu}[1][]     {p_{\nu_{\mu}}^{#1}}

\newcommand{\mB}             {m_{B}^{}}
\newcommand{\mCore}[1][]     {m_{\mathrm{core}}^{#1}}
\newcommand{\ECore}[1][]     {E_{\mathrm{core}}^{#1}}
\newcommand{\gammaCore}[1][] {\gamma_{\mathrm{core}}^{#1}}
\newcommand{\EMu}[1][]       {E_{\mu}^{#1}}

\begin{document}

\title{{\muXmodFull} user guide}

\author{Keith~Pedersen (kpeders1@hawk.iit.edu)}

\date{November 18, 2015}

\maketitle

\begin{abstract}
This user guide explains the function of the {\muXmodFull} module for
{\delphes}. This guide assumes that the reader has already read the
{\muX} boosted-$b$ tag paper~\cite{Pedersen:MuX}, and understands the
basics of the {\muX} tag.
\end{abstract}

\section{{\muXmodFull} basics}
The {\muXmodFull} module (henceforth frequently abbreviated as {\muXmod})
is a relatively straightforward extension to the standard {\delphes}
functionality. Like {\delphes}' native \texttt{BTagging} module, {\muXmod}
draws from \texttt{JetInputArray}, a list of fully reconstructed/calibrated
jets (e.g.\ from \texttt{JetEnergyScale}), and only alters their
\texttt{Candidate::BTag} bit-flag. Additionally, to allow {\muXmod} to be used
in conjunction with \texttt{BTagging}, {\muXmod} allows the user to define
\emph{which bit} in \texttt{BTag} is set when a jet is tagged (the {\muXmod}
default is bit-3, versus the \texttt{BTagging} default of bit-0).

Because the {\muX} boosted-$b$ tag only works for jets undergoing
semi-leptonic decay, the jets it tags systematically lack neutrino energy.
This means that {\muXmodFull} should perform an additional jet energy
correction, in the form of \textbf{neutrino estimation}. Currently, only the
simplest estimation is implemented: the neutrino's associated muon is used as
an exact proxy for the neutrino ($\pNu=\pMu$), since most of the momentum of
both comes from their shared boost. \emph{A more sophisticated estimate will 
improve the energy resolution}.

In order to accommodate this jet energy correction in a \emph{sensible} way,\linebreak
\texttt{JetInputArray} is cloned into \texttt{JetOutputArray}, and
only clone jets which are \emph{tagged} by {\muX} have their neutrino(s)
estimated. Thus, both input/output jets contain the same jets, in the same
order, with all the same fields (including \texttt{BTag}) --- \emph{except} when
they're tagged by {\muX}, in which case the version in \texttt{JetOutputArray}
will have a larger \texttt{Candidate::Momentum}.

These two lists of jets can be iterated through in parallel during
post-detector analysis code, giving the user the power to determine whether 
they want the original or corrected jet. For example, consider a dijet analysis 
which only requires a single $b$ tag. \emph{IFF} only one jet is {\muX}-tagged, 
then the event $\MET$ could be used for neutrino estimation (instead of $\pNu=\pMu$).
However, since a general process could possess other sources of $\MET$, this
decision should only only be made in post-analysis, not inside {\delphes}.

\section{Using {\muXmodFull}}

{\muXmod} will only tag jets \emph{which already contain muons}!
\textbf{There is no input array for muons!} This is a deliberate choice,
as these semi-leptonic muons are part of the jet, and should participate in jet 
clustering (allowing hard muons to seed anti-$k_T$ jets). Hence, 
the list of detected muons \emph{must} be merged into the input for 
jet clustering, otherwise {\muXmod} won't be able to tag anything.

Neutrino corrected jet clones (\texttt{MuX/JetOutputArray}) must be 
explicitly written out in \texttt{TreeWriter}. Alternatively, 
the user can manually correct the original jets during post-detector 
analysis (looping through the constituents of jets tagged by {\muXmod},
finding muons passing the $\pT$ cut, and estimating their $\nu_{\mu}$).

Since {\muXmodFull} can be used in conjunction with \texttt{BTagging}, the
\texttt{BTag} field can contain multiple flagged bits. Hence, 
\texttt{(BTag > 0)} only indicates a jet was tagged by \emph{some} module. 
To isolate a {\muX} tag, one can use bit-wise-AND.

\begin{lstlisting}
#include "DelphesClasses.h" // "Jet" class is defined here
... // A bunch of ROOT includes
const UInt_t muXbitNumber = 3;

const UInt_t bTaggingFlag = 1;
const UInt_t muXFlag = 1 << muXbitNumber;

TClonesArray* jetArray = 0;
TIterator* itJet = 0;
Jet* jet = 0;

// Read TTree, link &jetArray, loop over entries, GetEntry() (fill jetArray)
  // Initialize itJet, then use while to loop over all jets 
  while((jet = static_cast<Jet*>(itJet->Next())))
  {
    if((jet->BTag & bTaggingFlag) > 0) {//taggged by BTagging}
    if((jet->BTag & muXFlag) > 0){//taggged by MuXboostedBTagging}
  }
\end{lstlisting}
%
This {\delphes} card sets each {\muXmod} parameter to its default value.
%
\lstset{language=tcl, morekeywords={module}, commentstyle=\color{dkgreen}}

\begin{lstlisting}
module MuXboostedBTagging MuXboostedBTagging {
    set JetInputArray JetEnergyScale/jets
    set JetOutputArray jets

# Which bit to activate when a jet is tagged
    set BitNumber            3
# The main cuts in the tag (x_max and f_subjet^min)
    set MaxX                 3.0
    set MinCorePtRatio       0.5
# Basic kinematic cuts (to define taggable jets and taggable muons)
    set MinJetPt             300.
    set MinMuonPt            10.
# The core reclustering pT cut on towers
    set MinTowerPtRatio      0.05
# The core reclustering radius
    set CoreAntiKtR          0.04
# The minimum boost of a candidate core (low improves light-jet fake rate)
    set BCoreMinBoost        1.0
# The mass hypotheses
    set CoreMassHypothesis   2.0
    set SubjetMassHypothesis 5.3
# Maximum reconstructed subjet mass
    set MaxSubjetMass        12.
}
\end{lstlisting}

For a detailed understanding of {\muXmod}'s internal algorithm, please refer
to the source code, which has been extensively commented.

\section{Appendix}
\subsection{ECal pointing and standalone muons}

An important feature of the {\muX} paper~\cite{Pedersen:MuX} was its attempt to
sever its {\muX} tagging predictions from the tracking performance of
anything but ``standalone'' muons (muons which only require hits in the muon
chamber). To obtain the necessary angular resolution for the core
reconstruction, a procedure called ``ECal pointing'' was implemented (see the
paragraph directly before Sec. III-A in~\cite{Pedersen:MuX}).

The {\delphes} code to implement ECal pointing, ATLAS's standalone muon
efficiency, and the {\muXmodFull} can be found in ``./MuX.tcl''.

\subsection{\texttt{AllParticlePropagator}}

Part of the accurate simulation of the light jet efficiency was the simulation
of in-flight muon production inside the tracking volume (e.g. from
$\pi^{+}/K^{+}$ decay). Since the {\muX} tag is effectively an angular tag, it
was important to simulate the bending of the muon's mother. However, {\delphes}'
\texttt{ParticlePropagator} only propagates/bends ``final-state'' particles in
the magnetic field; their mothers (at least from \textsc{Pythia}) are propagated
to their decay vertices in a straight line.

Getting these muons required the activation of in-flight $\pi^{+}/K^{+}$ decay 
(off by default in \textsc{Pythia}), and the development of the 
\texttt{AllParticlePropagator} module to properly handle such decays 
(which also required custom handling of pileup). Since this module required 
alteration of the \texttt{Candidate} class (to store each particle's random,
proper lifetime) it is not currently distributed with {\muXmodFull}. This means that 
{\muXmod} will mildly \emph{over}-estimate the light jet fake rate (once 
in-flight $\pi^{+}/K^{+}$ decays are turned on), as muons from in-flight decays 
will arrive at slightly tighter angles to the reconstructed cores of their jets.

While \texttt{AllParticlePropagator} is available on
GitHub~\cite{Pedersen:myDelphes}, it is not designed for public use 
(i.e.\ no user guides, just the comments). It \emph{may} be officially released 
in the future, but this is not guaranteed.

\subsection{Robust subjet mass}

The subjet of a $B$~hadron decay is defined as
%
\begin{equation}
\pSubjet=\pCore+\pMu+\pNu,
\end{equation}
%
where the ``core'' is ostensibly a charm hadron.
Since the neutrino is not observable, we estimate it using the
simplest choice ($\pNu=\pMu$, since most of the momentum comes from
their shared boost). This gives us an approximate subjet
%
\begin{equation}
\pSubjet\approx\pCore+2\,\pMu.
\end{equation}
%

The muon is detected in the muon chamber, and core is found by reclustering the 
jet using a much smaller radius parameter. This produces a list of 
\emph{candidate} cores, of which only one is the ``correct'' core (the 
one which, using only the hardest muon in the jet, produces $\sqrt{\pSubjet[2]}$
closest to $\mB=5.3$~GeV, the mass of a $B$~hadron admixture). 
However, the mass of these core candidates is poorly measured (due
to the the granularity of the Calorimeter), which produces an inaccurate
value of $\sqrt{\pSubjet[2]}$. To alleviate this problem, $\mCore$ is simply
constrained to its expected mass, given the $B$~hadron decay hypothesis 
($\mCore=2$~GeV, the approximate mass of a charm hadron). 

The correct core is found by finding the minimum value of 
$\left|\sqrt{\pSubjet[2]}-m_B^{}\right|$. In order to complete this search 
quickly, we don't want to correct the mass of each core candidate before
adding the muon. Instead, we can use our large cut on muon $\pT$ to treat
the muon as massless, then calculate the mass of the subjet analytically
%
\begin{eqnarray}
\pSubjet[2] & = & \mCore[2]+4\,\pCore\cdot\pMu \nonumber \\
& = & \mCore[2]+4\,\EMu\ECore(1-\cos(\xi)\sqrt{1-g}),
\end{eqnarray}
%
where $\xi$ is the angle between the muon and the core and $g\equiv\gammaCore[-2]$.
Using $y\equiv\tan^{2}(\xi)=\left(\frac{\pCoreV\times\pMuV}{\pCoreV\cdot\pMuV}\right)^2$
and $\cos(\xi)=\frac{1}{\sqrt{1+y}}$ (since $\xi<\pi/2$), this becomes
%
\begin{equation}
\pSubjet[2]=\mCore[2]+4\,\EMu\ECore(1-\frac{\sqrt{1-g}}{\sqrt{1+y}}).
\end{equation}
%

This expression can be optimized to minimize floating point cancellation,
(which should be minuscule, but mitigating cancellation is a good habit)
%
\begin{equation}
\pSubjet[2]=\mCore[2]+4\,\EMu\ECore\frac{g+y}{1+y+\sqrt{1-((g-y)+g\,y)}}.
\end{equation}

\begin{thebibliography}{}

\bibitem{Pedersen:MuX}
  K.~Pedersen and Z.~Sullivan,
  %``The working title''
  [arXiv:1511.05990 [hep-ph]]

\bibitem{Pedersen:myDelphes}
  \url{https://github.com/keith-pedersen/delphes/tree/myDelphes}

\end{thebibliography}

\end{document}
